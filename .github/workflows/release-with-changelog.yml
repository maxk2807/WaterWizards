name: Release with Changelog

on:
  push:
    branches: [ "main" ]
  pull_request:
    types: [closed]
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
        default: ''

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)

    permissions:
      contents: write 

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Run NUKE Build
        run: ./build.sh Clean Compile Test

      - name: Publish Client (Windows)
        run: dotnet publish src/WaterWizard.Client/WaterWizard.Client.csproj -c Release -r win-x64 --self-contained true -o ./publish/win --verbosity normal -p:PublishSingleFile=false -p:IncludeNativeLibrariesForSelfExtract=true

      - name: Publish Server (Windows)
        run: dotnet publish src/WaterWizard.Server/WaterWizard.Server.csproj -c Release -r win-x64 --self-contained true -o ./publish/win-server

      - name: Publish Client (MacOS)
        run: dotnet publish src/WaterWizard.Client/WaterWizard.Client.csproj -c Release -r osx-x64 --self-contained true -o ./publish/osx --verbosity normal -p:PublishSingleFile=false -p:IncludeNativeLibrariesForSelfExtract=true

      - name: Publish Server (MacOS)
        run: dotnet publish src/WaterWizard.Server/WaterWizard.Server.csproj -c Release -r osx-x64 --self-contained true -o ./publish/osx-server

      - name: Publish Client (Linux)
        run: dotnet publish src/WaterWizard.Client/WaterWizard.Client.csproj -c Release -r linux-x64 --self-contained true -o ./publish/linux --verbosity normal -p:PublishSingleFile=false -p:IncludeNativeLibrariesForSelfExtract=true

      - name: Publish Server (Linux)
        run: dotnet publish src/WaterWizard.Server/WaterWizard.Server.csproj -c Release -r linux-x64 --self-contained true -o ./publish/linux-server

      - name: Prepare release assets
        run: |
          mkdir release-assets

          # Find the actual executable names
          WIN_EXE=$(find ./publish/win -name "*.exe" -type f | head -1)
          OSX_EXE=$(find ./publish/osx -type f -executable | grep -v "\.dll$" | grep -v "\.so$" | grep -v "\.dylib$" | head -1)
          LINUX_EXE=$(find ./publish/linux -type f -executable | grep -v "\.dll$" | grep -v "\.so$" | grep -v "\.dylib$" | head -1)
          
          # Copy Windows executable
          if [ -n "$WIN_EXE" ]; then
            cp "$WIN_EXE" release-assets/WaterWizard.Client.exe
            echo "‚úÖ Windows executable found and copied"
          else
            echo "‚ùå Warning: No Windows executable found"
          fi
          
          # Copy macOS executable
          if [ -n "$OSX_EXE" ]; then
            cp "$OSX_EXE" release-assets/WaterWizard.Client.MacOS
            chmod +x release-assets/WaterWizard.Client.MacOS
            echo "‚úÖ macOS executable found and copied"
          else
            echo "‚ùå Warning: No MacOS executable found"
          fi
          
          # Copy Linux executable
          if [ -n "$LINUX_EXE" ]; then
            cp "$LINUX_EXE" release-assets/WaterWizard.Client.Linux
            chmod +x release-assets/WaterWizard.Client.Linux
            echo "‚úÖ Linux executable found and copied"
          else
            echo "‚ùå Warning: No Linux executable found"
          fi
          
          # Also package as archives for easier distribution
          cd ./publish
          if [ -d "win" ]; then
            zip -r ../release-assets/WaterWizard.Client.Windows.zip win/
          fi
          if [ -d "osx" ]; then
            tar -czf ../release-assets/WaterWizard.Client.MacOS.tar.gz osx/
          fi
          if [ -d "linux" ]; then
            tar -czf ../release-assets/WaterWizard.Client.Linux.tar.gz linux/
          fi
          cd ..
          
          echo "Release assets:"
          ls -la release-assets/

      - name: Debug published files
        run: |
          echo "=== Windows publish directory ==="
          ls -la ./publish/win/
          echo "=== macOS publish directory ==="
          ls -la ./publish/osx/
          echo "=== Linux publish directory ==="
          ls -la ./publish/linux/
          
          echo "=== Checking for native libraries ==="
          find ./publish -name "*.dll" -o -name "*.so" -o -name "*.dylib" | head -20

      - name: Get and increment version if needed
        id: get_version
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git fetch --tags
          
          # Use manual version if provided
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Get current version from .csproj
            PROJECT_VERSION=$(grep -m1 '<Version>' src/WaterWizard.Server/WaterWizard.Server.csproj | sed -E 's/.*<Version>(.+)<\/Version>.*/\1/')
            
            # Get latest tag version
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$LATEST_TAG" ]; then
              LATEST_VERSION=${LATEST_TAG#v}  # Remove 'v' prefix
            else
              LATEST_VERSION="0.0.0"
            fi
            
            echo "Project version: $PROJECT_VERSION"
            echo "Latest tag: $LATEST_TAG"
            echo "Latest tag version: $LATEST_VERSION"
            
            # Use the higher version between project and latest tag
            if [ -n "$PROJECT_VERSION" ] && [ "$PROJECT_VERSION" != "0.0.0" ]; then
              VERSION="$PROJECT_VERSION"
              echo "Using project version: $VERSION"
            else
              VERSION="$LATEST_VERSION"
              echo "Using latest tag version: $VERSION"
            fi
            
            # Parse version components
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f2)
            PATCH=$(echo "$VERSION" | cut -d. -f3)
            [ -z "$PATCH" ] && PATCH=0
            
            # Increment patch version for next release
            PATCH=$((PATCH + 1))
            VERSION="$MAJOR.$MINOR.$PATCH"
            
            echo "Incremented version: $VERSION"
          fi
          
          TAG="v$VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          
          # Check if tag already exists
          if git rev-parse "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "‚ùå Tag $TAG already exists! Incrementing patch version..."
            PATCH=$((PATCH + 1))
            VERSION="$MAJOR.$MINOR.$PATCH"
            TAG="v$VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          fi
          
          echo "Final version: $VERSION"
          echo "Final tag: $TAG"

      - name: Generate Intelligent Changelog
        id: changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$PREVIOUS_TAG" ]; then
            # First release - get all PRs
            PRS=$(gh pr list --state merged --json title,number,author,mergedAt --limit 100)
          else
            # Get PRs merged since last tag
            PREVIOUS_DATE=$(git log -1 --format=%cd --date=iso ${PREVIOUS_TAG})
            PRS=$(gh pr list --state merged --json title,number,author,mergedAt --limit 100 --search "merged:>${PREVIOUS_DATE}")
          fi
          
          # Create changelog with PR format
          CHANGELOG="## üöÄ What's Changed in v${{ steps.get_version.outputs.version }}

          "
          
          # Process PRs and format them
          if [ -n "$PRS" ] && [ "$PRS" != "[]" ]; then
            echo "$PRS" | jq -r '.[] | "\(.title) by @\(.author.login) in #\(.number)"' | while read -r line; do
              if [ -n "$line" ]; then
                CHANGELOG+="$line"$'\n'
              fi
            done
          else
            CHANGELOG+="No new changes in this release"$'\n'
          fi
          
          CHANGELOG+="

          ### üì¶ Installation & Usage

          #### ü™ü Windows
          1. Download \`WaterWizard.Client.exe\` or \`WaterWizard.Client.Windows.zip\`
          2. Run the executable
          3. Host or join a game

          #### üçé macOS
          1. Download \`WaterWizard.Client.MacOS\` or \`WaterWizard.Client.MacOS.tar.gz\`
          2. Make it executable: \`chmod +x WaterWizard.Client.MacOS\`
          3. Run the game

          #### üêß Linux
          1. Download \`WaterWizard.Client.Linux\` or \`WaterWizard.Client.Linux.tar.gz\`
          2. Make it executable: \`chmod +x WaterWizard.Client.Linux\`
          3. Run the game

          #### üîß Development Setup
          \`\`\`bash
          # Clone the repository
          git clone https://github.com/maxk2807/WaterWizards.git
          cd WaterWizards

          # Use the optimized launcher
          ./start-game
          \`\`\`

          ### üéØ Quick Start
          1. **Host Game**: Click \"Host Game\" in the first client
          2. **Join Game**: Click \"Join Game\" in the second client, enter \"localhost\"
          3. **Ready Up**: Both players click \"Ready\"
          4. **Start Game**: Click \"Start Game\" to begin

          ---
          *This release was automatically generated by GitHub Actions*
          *Generated on: $(date -u +'%Y-%m-%d %H:%M:%S UTC')*"
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release & Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.tag }}
          name: Release ${{ steps.get_version.outputs.version }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false
          files: release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}